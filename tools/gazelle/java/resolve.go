package java

import (
	"fmt"
	"log"
	"os"
	"strings"

	"github.com/bazelbuild/bazel-gazelle/config"
	"github.com/bazelbuild/bazel-gazelle/label"
	"github.com/bazelbuild/bazel-gazelle/repo"
	"github.com/bazelbuild/bazel-gazelle/resolve"
	"github.com/bazelbuild/bazel-gazelle/rule"
	bzl "github.com/bazelbuild/buildtools/build"
	"github.com/emirpasic/gods/sets/treeset"
	godsutils "github.com/emirpasic/gods/utils"
)

// Resolver satisfies the resolve.Resolver interface. It resolves dependencies
// in rules generated by this extension.
type Resolver struct{}

// Name returns the name of the language. This should be a prefix of the
// kinds of rules generated by the language, e.g., "go" for the Go extension
// since it generates "go_library" rules.
func (*Resolver) Name() string {
	return JavaName
}

// Imports returns a list of ImportSpecs that can be used to import the rule
// r. This is used to populate RuleIndex.
//
// If nil is returned, the rule will not be indexed. If any non-nil slice is
// returned, including an empty slice, the rule will be indexed.
//
// NOTE(jacob): Doc translation: "Return the packages defined by this BUILD target." This
//		is a dead simple implementation currently. Assumptions made:
//		- we have no packages split across build targets
//		- package structure matches directory structure, ignoring the top-level module name
//			and source tree prefix
//		- targets only contain sources in their immediate directory, no sub-directories
func (*Resolver) Imports(
	c *config.Config,
	r *rule.Rule,
	f *rule.File,
) []resolve.ImportSpec {
	cfg := c.Exts[JavaName].(JavaConfig)
	sourceTreePrefix := cfg.SourceTreePrefix
	packageStartIndex := strings.Index(f.Pkg, sourceTreePrefix) + len(sourceTreePrefix)
	javaPackage := strings.ReplaceAll(f.Pkg[packageStartIndex:], "/", ".")

	return []resolve.ImportSpec{
		resolve.ImportSpec{
			Lang: JavaName,
			Imp: javaPackage,
		},
	}
}

// Embeds returns a list of labels of rules that the given rule embeds. If
// a rule is embedded by another importable rule of the same language, only
// the embedding rule will be indexed. The embedding rule will inherit
// the imports of the embedded rule.
func (*Resolver) Embeds(r *rule.Rule, from label.Label) []label.Label {
	// TODO(jacob): nothing to do here for java?
	return make([]label.Label, 0)
}

// Resolve translates imported libraries for a given rule into Bazel
// dependencies. Information about imported libraries is returned for each
// rule generated by language.GenerateRules in
// language.GenerateResult.Imports. Resolve generates a "deps" attribute (or
// the appropriate language-specific equivalent) for each import according to
// language-specific rules and heuristics.
func (*Resolver) Resolve(
	c *config.Config,
	ruleIndex *resolve.RuleIndex,
	rc *repo.RemoteCache,
	r *rule.Rule,
	imports interface{},
	from label.Label,
) {
	deps := treeset.NewWith(godsutils.StringComparator)

	it := imports.(*treeset.Set).Iterator()
	for it.Next() {
		javaPackage := it.Value().(string)
		javaImportSpec := resolve.ImportSpec{
			Lang: JavaName,
			Imp: javaPackage,
		}
		foundRules := ruleIndex.FindRulesByImportWithConfig(c, javaImportSpec, JavaName)

		if len(foundRules) != 1 {
			if len(foundRules) == 0 {
				log.Printf(
					"ERROR: failed to find a BUILD target containing the \"%s\" package",
					javaPackage,
				)

			} else {
				targets := make([]string, len(foundRules))
				for i, foundRule := range foundRules {
					targets[i] = fmt.Sprintf("%s:%s", foundRule.Label.Pkg, foundRule.Label.Name)
				}
				log.Printf(
					"ERROR: multiple BUILD targets containing the \"%s\" package: %+q",
					javaPackage,
					targets,
				)
			}

			os.Exit(1)

		} else {
			// TODO(jacob): This assumes the target name matches the package/directory name,
			//		which is at least mostly true but possibly not always true? It does look
			//		cleaner though.
			deps.Add(foundRules[0].Label.Pkg)
		}
	}

	r.SetAttr("deps", convertDependencySetToExpr(deps))
}

// convertDependencySetToExpr converts the given set of dependencies to an
// expression to be used in the deps attribute.
//
// from https://github.com/bazelbuild/rules_python/blob/27d0c7bb8e663dd2e2e9b295ecbfed680e641dfd/gazelle/resolve.go#L264-L274
func convertDependencySetToExpr(set *treeset.Set) bzl.Expr {
	deps := make([]bzl.Expr, set.Size())
	it := set.Iterator()
	for it.Next() {
		dep := it.Value().(string)
		deps[it.Index()] = &bzl.StringExpr{Value: dep}
	}
	return &bzl.ListExpr{List: deps}
}
